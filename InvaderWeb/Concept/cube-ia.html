<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL 2.0 - Cubo 3D orientado al cursor</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>

  <!-- Librería gl-matrix para operaciones de matrices y vectores -->
  <!--script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script-->
  <script type="text/javascript" src="../../WebGLEngine/engine/m4.js"></script>
  <script>
    (() => {
      const canvas = document.getElementById('glcanvas');
      const gl = canvas.getContext('webgl2');
      if (!gl) {
        alert('WebGL 2.0 no está disponible en este navegador.');
        return;
      }

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Variables de control
      let yRotation = 0;
      let mouseX = 0, mouseY = 0;

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouseY = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      });

      // Vertices con color intercalado
      const positions = new Float32Array([
        // Front
        -1, -1,  1,  1, 0, 0,
         1, -1,  1,  0, 1, 0,
         1,  1,  1,  0, 0, 1,
        -1,  1,  1,  1, 1, 0,
        // Back
        -1, -1, -1,  1, 0, 1,
         1, -1, -1,  0, 1, 1,
         1,  1, -1,  1, 1, 1,
        -1,  1, -1,  0.5, 0.5, 0.5,
      ]);
      const indices = new Uint16Array([
        0, 1, 2, 0, 2, 3,      // Front
        1, 5, 6, 1, 6, 2,      // Right
        5, 4, 7, 5, 7, 6,      // Back
        4, 0, 3, 4, 3, 7,      // Left
        3, 2, 6, 3, 6, 7,      // Top
        4, 5, 1, 4, 1, 0       // Bottom
      ]);

      const vsSource = `#version 300 es
      in vec3 aPosition;
      in vec3 aColor;
      uniform m4 uMVP;
      out vec3 vColor;
      void main() {
        gl_Position = uMVP * vec4(aPosition, 1.0);
        vColor = aColor;
      }`;

      const fsSource = `#version 300 es
      precision mediump float;
      in vec3 vColor;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(vColor, 1.0);
      }`;

      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      function createProgram(vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }

      const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);
      const program = createProgram(vertexShader, fragmentShader);

      const aPosition = gl.getAttribLocation(program, 'aPosition');
      const aColor = gl.getAttribLocation(program, 'aColor');
      const uMVP = gl.getUniformLocation(program, "uMVP");

      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 6 * 4, 0);

      gl.enableVertexAttribArray(aColor);
      gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 6 * 4, 3 * 4);

      const ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      // Matrices
      const model = m4.create();
      const view = m4.create();
      const proj = m4.create();
      const mvp = m4.create();
      const eye = [0, 0, 6];
      const up = [0, 1, 0];
      const center = [0, 0, 0];

      gl.enable(gl.DEPTH_TEST);

      function render() {
        requestAnimationFrame(render);
        gl.clearColor(0.1, 0.1, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        yRotation += 0.01;

        m4.identity(model);
        m4.rotateY(model, model, yRotation);

        // Apuntar cara frontal al cursor
        const front = vec3.fromValues(0, 0, 1);
        const cursorDir = vec3.fromValues(mouseX * 3, mouseY * 3, 0);
        const rotMatrix = getLookAtRotation(front, cursorDir);
        m4.multiply(model, rotMatrix, model);

        m4.lookAt(view, eye, center, up);
        m4.perspective(proj, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
        m4.multiply(mvp, proj, view);
        m4.multiply(mvp, mvp, model);

        gl.useProgram(program);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uMVP, false, mvp);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      }

      // Calcula rotación para alinear el vector 'from' con 'to'
      function getLookAtRotation(from, to) {
        const axis = vec3.create();
        vec3.cross(axis, from, to);
        const angle = Math.acos(vec3.dot(vec3.normalize(vec3.create(), from), vec3.normalize(vec3.create(), to)));
        const rot = m4.create();
        if (vec3.length(axis) > 0.0001) {
          m4.rotate(rot, m4.create(), angle, axis);
        } else {
          m4.identity(rot);
        }
        return rot;
      }

      render();
    })();
  </script>
</body>
</html>