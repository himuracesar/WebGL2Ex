<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 Stencil Debugger - Pure JS</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; border: 1px solid #444; }
        .key { color: #0af; font-weight: bold; }
        .status { color: #f0f; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <h2 style="margin-top:0">Visualizador de Stencil Buffer</h2>
        <p>Esfera: <span class="key">Valor 1 en Stencil</span></p>
        <p>Modo Debug: <span class="status">ACTIVADO (Overlay Magenta)</span></p>
        <p><small>El área magenta representa los píxeles marcados<br>donde NO se dibujará el outline.</small></p>
    </div>
    <canvas id="gl-canvas"></canvas>

    <script id="vs-debug" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec2 a_position;
        void main() {
            // Un quad que cubre toda la pantalla en Clip Space
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fs-debug" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        out vec4 outColor;
        void main() {
            // Color magenta semitransparente para representar el Stencil
            outColor = vec4(1.0, 0.0, 1.0, 0.4); 
        }
    </script>

    <script id="vs-basic" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;
        uniform mat4 u_projection, u_view, u_model;
        out vec3 v_normal;
        void main() {
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
        }
    </script>

    <script id="fs-basic" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_normal;
        out vec4 outColor;
        uniform vec3 u_color;
        void main() {
            vec3 light = normalize(vec3(0.5, 1.0, 0.5));
            float d = max(dot(normalize(v_normal), light), 0.2);
            outColor = vec4(u_color * d, 1.0);
        }
    </script>

    <script>
        "use strict";

        // --- Lógica de Matrices (Simplificada para el ejemplo) ---
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (fovy, aspect, near, far) => {
                let f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
            },
            lookAt: (eye, center, up) => {
                const z = normalize(subtract(eye, center)), x = normalize(cross(up, z)), y = cross(z, x);
                return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
            },
            translate: (m, v) => {
                m[12] += m[0]*v[0] + m[4]*v[1] + m[8]*v[2];
                m[13] += m[1]*v[0] + m[5]*v[1] + m[9]*v[2];
                m[14] += m[2]*v[0] + m[6]*v[1] + m[10]*v[2];
                return m;
            }
        };
        const subtract = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
        const cross = (a, b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        const normalize = (a) => { let l = 1/Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]); return [a[0]*l, a[1]*l, a[2]*l]; };
        const dot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];

        // --- Generación de Geometría ---
        function createSphere(r, s) {
            let p = [], n = [], i = [];
            for(let y=0; y<=s; y++) {
                let lat = y*Math.PI/s, sinLat = Math.sin(lat), cosLat = Math.cos(lat);
                for(let x=0; x<=s; x++) {
                    let lon = x*2*Math.PI/s, ux = Math.cos(lon)*sinLat, uy = cosLat, uz = Math.sin(lon)*sinLat;
                    p.push(r*ux, r*uy, r*uz); n.push(ux, uy, uz);
                }
            }
            for(let y=0; y<s; y++) {
                for(let x=0; x<s; x++) {
                    let f = y*(s+1)+x, sec = f+s+1;
                    i.push(f, sec, f+1, sec, sec+1, f+1);
                }
            }
            return { pos: new Float32Array(p), norm: new Float32Array(n), idx: new Uint16Array(i) };
        }

        async function init() {
            const canvas = document.getElementById("gl-canvas");
            const gl = canvas.getContext("webgl2", { stencil: true });

            function createProg(vs, fs) {
                const p = gl.createProgram();
                [vs, fs].forEach((src, i) => {
                    const s = gl.createShader(i ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER);
                    gl.shaderSource(s, document.getElementById(src).text);
                    gl.compileShader(s);
                    gl.attachShader(p, s);
                });
                gl.linkProgram(p);
                return p;
            }

            const progBasic = createProg("vs-basic", "fs-basic");
            const progDebug = createProg("vs-debug", "fs-debug");

            // VAO para la Esfera
            const sphere = createSphere(25, 32);
            const vaoSphere = gl.createVertexArray();
            gl.bindVertexArray(vaoSphere);
            const bPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bPos); gl.bufferData(gl.ARRAY_BUFFER, sphere.pos, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            const bNorm = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bNorm); gl.bufferData(gl.ARRAY_BUFFER, sphere.norm, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
            const bIdx = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bIdx); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.idx, gl.STATIC_DRAW);

            // VAO para el Quad de Depuración (Full Screen)
            const vaoQuad = gl.createVertexArray();
            gl.bindVertexArray(vaoQuad);
            const quadPos = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
            const bQuad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bQuad); gl.bufferData(gl.ARRAY_BUFFER, quadPos, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            function render() {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0.02, 0.02, 0.02, 1);
                gl.clearStencil(0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                const proj = mat4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1000);
                const view = mat4.lookAt([0, 50, 120], [0, 0, 0], [0, 1, 0]);

                // 1. DIBUJAR ESFERA Y ESCRIBIR EN STENCIL
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.STENCIL_TEST);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE); // Reemplazar con 1
                gl.stencilFunc(gl.ALWAYS, 1, 0xFF);         // Escribir '1'
                gl.stencilMask(0xFF);

                gl.useProgram(progBasic);
                gl.uniformMatrix4fv(gl.getUniformLocation(progBasic, "u_projection"), false, proj);
                gl.uniformMatrix4fv(gl.getUniformLocation(progBasic, "u_view"), false, view);
                gl.uniformMatrix4fv(gl.getUniformLocation(progBasic, "u_model"), false, mat4.translate(mat4.identity(), [-25, 0, 0]));
                gl.uniform3f(gl.getUniformLocation(progBasic, "u_color"), 0.8, 0.1, 0.1);
                gl.bindVertexArray(vaoSphere);
                gl.drawElements(gl.TRIANGLES, sphere.idx.length, gl.UNSIGNED_SHORT, 0);

                // 2. PASO DE VISUALIZACIÓN DE STENCIL (DEBUG)
                // Aquí es donde "vemos" la textura generada internamente
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                // Configuración crítica: Solo dibujamos el quad donde el stencil sea igual a 1
                gl.stencilFunc(gl.EQUAL, 1, 0xFF);
                gl.stencilMask(0x00); // No queremos escribir más en el stencil
                gl.disable(gl.DEPTH_TEST); // Para que se vea sobre el objeto

                gl.useProgram(progDebug);
                gl.bindVertexArray(vaoQuad);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                gl.disable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                requestAnimationFrame(render);
            }

            window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
            window.onresize();
            requestAnimationFrame(render);
        }
        init();
    </script>
</body>
</html>