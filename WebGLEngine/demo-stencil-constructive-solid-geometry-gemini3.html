<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 CSG Subtraction - Expert Level</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #eee; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.8); padding: 20px; border-left: 5px solid #f44; }
        .code { color: #f44; font-family: monospace; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <h3 style="margin-top:0">CSG: Sustracción Booleana</h3>
        <p>Operación: <span class="code">Esfera - Cubo</span></p>
        <p><small>El cubo es invisible, pero su silueta "recorta"<br>los píxeles de la esfera en tiempo real.</small></p>
    </div>
    <canvas id="gl-canvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">#version 300 es
        layout(location=0) in vec3 a_p;
        layout(location=1) in vec3 a_n;
        uniform mat4 u_p, u_v, u_m;
        out vec3 v_n;
        void main() {
            v_n = mat3(u_m) * a_n;
            gl_Position = u_p * u_v * u_m * vec4(a_p, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_n;
        out vec4 o;
        uniform vec3 u_c;
        void main() {
            float d = max(dot(normalize(v_n), normalize(vec3(1,1,1))), 0.2);
            o = vec4(u_c * d, 1.0);
        }
    </script>

    <script>
        "use strict";

        // --- BIBLIOTECA MATEMÁTICA SENIOR ---
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (f, a, n, r) => { let s=1/Math.tan(f/2), d=1/(n-r); return new Float32Array([s/a,0,0,0, 0,s,0,0, 0,0,(r+n)*d,-1, 0,0,2*r*n*d,0]); },
            lookAt: (e, c, u) => {
                const norm = (v) => { let l=1/Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]*l,v[1]*l,v[2]*l]; };
                const cross = (a,b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
                const dot = (a,b) => a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
                const z=norm([e[0]-c[0], e[1]-c[1], e[2]-c[2]]), x=norm(cross(u,z)), y=cross(z,x);
                return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,e),-dot(y,e),-dot(z,e),1]);
            },
            translate: (m, v) => { m[12]+=v[0]; m[13]+=v[1]; m[14]+=v[2]; return m; }
        };

        // --- GENERACIÓN DE GEOMETRÍA ---
        function createSphere(r, s) {
            let p=[], n=[], idx=[];
            for(let y=0; y<=s; y++){
                let lat=y*Math.PI/s, sl=Math.sin(lat), cl=Math.cos(lat);
                for(let x=0; x<=s; x++){
                    let lon=x*2*Math.PI/s, ux=Math.cos(lon)*sl, uy=cl, uz=Math.sin(lon)*sl;
                    p.push(r*ux,r*uy,r*uz); n.push(ux,uy,uz);
                }
            }
            for(let y=0; y<s; y++) for(let x=0; x<s; x++){
                let f=y*(s+1)+x, sec=f+s+1; idx.push(f,sec,f+1,sec,sec+1,f+1);
            }
            return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) };
        }

        function createCube(s) {
            let h=s/2;
            let p = new Float32Array([-h,-h,h, h,-h,h, h,h,h, -h,h,h, -h,-h,-h, -h,h,-h, h,h,-h, h,-h,-h, -h,h,-h, -h,h,h, h,h,h, h,h,-h, -h,-h,-h, h,-h,-h, h,-h,h, -h,-h,h, h,-h,-h, h,h,-h, h,h,h, h,-h,h, -h,-h,-h, -h,-h,h, -h,h,h, -h,h,-h]);
            let n = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0]);
            let i = new Uint16Array([0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23]);
            return { p, n, i };
        }

        async function init() {
            const canvas = document.getElementById("gl-canvas");
            const gl = canvas.getContext("webgl2", { stencil: true, antialias: true });

            const prog = gl.createProgram();
            [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((t, i) => {
                const s = gl.createShader(t);
                gl.shaderSource(s, document.getElementById(i ? "fs" : "vs").text);
                gl.compileShader(s); gl.attachShader(prog, s);
            });
            gl.linkProgram(prog); gl.useProgram(prog);

            const setupVAO = (geo) => {
                const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ARRAY_BUFFER, geo.p, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ARRAY_BUFFER, geo.n, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geo.i, gl.STATIC_DRAW);
                return vao;
            };

            const sphereVAO = setupVAO(createSphere(30, 32));
            const cubeVAO = setupVAO(createCube(35));

            const uM = gl.getUniformLocation(prog, "u_m");
            const uC = gl.getUniformLocation(prog, "u_c");
            const uP = gl.getUniformLocation(prog, "u_p");
            const uV = gl.getUniformLocation(prog, "u_v");

            function render(time) {
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                
                // Limpiamos todo, incluyendo el stencil a 0
                gl.clearColor(0.02, 0.02, 0.02, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                const proj = mat4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1000);
                const view = mat4.lookAt([0, 80, 150], [0, 0, 0], [0, 1, 0]);
                gl.uniformMatrix4fv(uP, false, proj);
                gl.uniformMatrix4fv(uV, false, view);

                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.STENCIL_TEST);

                // --- PASO 1: CREAR EL "AGUJERO" CON EL CUBO ---
                // No queremos ver el cubo, solo marcar su posición en el stencil
                gl.colorMask(false, false, false, false); 
                gl.depthMask(false); // No escribir en el buffer de profundidad

                gl.stencilFunc(gl.ALWAYS, 0x01, 0xFF); // Siempre pasa
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE); // Escribir 1 donde esté el cubo
                gl.stencilMask(0xFF);

                let cubeModel = mat4.translate(mat4.identity(), [20 * Math.sin(time*0.0015), 0, 30]);
                gl.uniformMatrix4fv(uM, false, cubeModel);
                gl.bindVertexArray(cubeVAO);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

                // --- PASO 2: RENDERIZAR LA ESFERA CON LA SUSTRACCIÓN ---
                // Rehabilitamos el color y la profundidad
                gl.colorMask(true, true, true, true);
                gl.depthMask(true);

                // Lógica de sustracción: Solo dibujar donde el stencil NO sea 1
                gl.stencilFunc(gl.NOTEQUAL, 0x01, 0xFF);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // No modificar el stencil más

                gl.uniformMatrix4fv(uM, false, mat4.identity());
                gl.uniform3f(uC, 0.9, 0.1, 0.1);
                gl.bindVertexArray(sphereVAO);
                gl.drawElements(gl.TRIANGLES, 32*32*6, gl.UNSIGNED_SHORT, 0);

                gl.disable(gl.STENCIL_TEST);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        init();
    </script>
</body>
</html>