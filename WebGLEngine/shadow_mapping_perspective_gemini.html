<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 Spot Light Shadow Mapping Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gl-canvas"></canvas>
    <script>
        // =====================================================================
        // CONFIGURACIÓN DE ESCENA Y DIMENSIONES
        // =====================================================================
        const CANVAS = document.getElementById('gl-canvas');
        const GL = CANVAS.getContext('webgl2');

        if (!GL) {
            alert('Su navegador no soporta WebGL2.');
        }

        const SHADOW_MAP_SIZE = 2048; // Resolución del mapa de sombras
        
        // Dimensiones de la escena (unidades de mundo)
        const GRID_SIZE = 200.0;
        const SPHERE_RADIUS = 5.0;
        const CUBE_SIZE = 5.0;

        // Posiciones base (sobre Y=0)
        const SPHERE_POS = [-5.0, SPHERE_RADIUS, 0.0];
        const CUBE_POS = [5.0, CUBE_SIZE / 2.0, 0.0];

        // --- PARÁMETROS DE LA SPOT LIGHT ---
        const LIGHT_POS = [0.0, 25.0, 0.0];      // Posición elevada de la lámpara
        const LIGHT_TARGET = [0.0, 0.0, 0.0];    // Hacia donde apunta (centro de la escena)
        const LIGHT_DIRECTION = normalize([LIGHT_TARGET[0] - LIGHT_POS[0], LIGHT_TARGET[1] - LIGHT_POS[1], LIGHT_TARGET[2] - LIGHT_POS[2]]);
        
        // Ángulos del cono de luz (en radianes)
        const OUTER_CONE = Math.cos(20.0 * Math.PI / 180.0); // 20 grados
        const INNER_CONE = Math.cos(15.0 * Math.PI / 180.0); // 15 grados

        // Parámetros de la cámara principal
        const CAMERA_POS = [0.0, 15.0, 25.0];
        const CAMERA_TARGET = [0.0, 0.0, 0.0];
        const FOV = 45 * Math.PI / 180;
        const NEAR = 0.1;
        const FAR = 200.0;

        // =====================================================================
        // SHADERS GLSL
        // =====================================================================

        // Shader de Vértices para el Paso de Profundidad (Light View)
        const SHADOW_VS_SOURCE = `#version 300 es
            layout(location = 0) in vec3 a_position;
            uniform mat4 u_lightMatrix;
            void main() {
                gl_Position = u_lightMatrix * vec4(a_position, 1.0);
            }
        `;

        // Shader de Fragmentos para el Paso de Profundidad (solo escribe profundidad)
        const SHADOW_FS_SOURCE = `#version 300 es
            precision highp float;
            void main() {
                // No necesitamos escribir color, solo la profundidad en el FBO
            }
        `;

        // Shader de Vértices para el Renderizado de la Escena (Main View)
        const SCENE_VS_SOURCE = `#version 300 es
            layout(location = 0) in vec3 a_position;
            layout(location = 1) in vec3 a_normal;
            
            uniform mat4 u_model;
            uniform mat4 u_view;
            uniform mat4 u_projection;
            uniform mat4 u_lightViewProjection;

            out vec3 v_normal;
            out vec3 v_worldPos;
            out vec4 v_lightSpacePos;

            void main() {
                v_worldPos = (u_model * vec4(a_position, 1.0)).xyz;
                v_normal = mat3(transpose(inverse(u_model))) * a_normal; 
                v_lightSpacePos = u_lightViewProjection * vec4(v_worldPos, 1.0);
                gl_Position = u_projection * u_view * vec4(v_worldPos, 1.0);
            }
        `;

        // Shader de Fragmentos para el Renderizado de la Escena (Spot Light con Shadow Mapping)
        const SCENE_FS_SOURCE = `#version 300 es
            precision highp float;

            in vec3 v_normal;
            in vec3 v_worldPos;
            in vec4 v_lightSpacePos;
            
            uniform sampler2D u_shadowMap;
            
            // Parámetros de la Spot Light
            uniform vec3 u_lightPos;
            uniform vec3 u_lightDir;
            uniform float u_innerCone;
            uniform float u_outerCone;

            uniform vec3 u_viewPos;
            uniform vec3 u_objectColor;
            
            out vec4 fragColor;

            // Función para calcular la atenuación del cono de luz
            float spotFalloff(vec3 L) {
                vec3 lightDir = normalize(u_lightDir);
                float theta = dot(L, -lightDir); // Ángulo entre rayo de luz y dirección de foco
                
                if (theta > u_innerCone) {
                    return 1.0; // Interior del cono
                }
                if (theta < u_outerCone) {
                    return 0.0; // Fuera del cono
                }

                // Atenuación suave (smoothstep)
                float epsilon = u_innerCone - u_outerCone;
                return clamp((theta - u_outerCone) / epsilon, 0.0, 1.0);
            }

            // Cálculo de sombras
            float calculateShadow(vec3 projCoords) {
                // Si está fuera del frustum de la luz, no hay sombra (ni luz de foco)
                if (projCoords.z > 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0) {
                    return 0.0; 
                }

                float currentDepth = projCoords.z;
                float closestDepth = texture(u_shadowMap, projCoords.xy).r;

                // Aplicar Shadow Bias
                float bias = 0.002;
                if (closestDepth < currentDepth - bias) {
                    return 1.0; // Sombreado
                }

                return 0.0; // Iluminado
            }

            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightVec = u_lightPos - v_worldPos;
                float distance = length(lightVec);
                vec3 L = normalize(lightVec); // Dirección del rayo de luz

                // --- ILUMINACIÓN AMBIENTE ---
                vec3 ambient = 0.1 * u_objectColor;

                // --- SPOT LIGHT CALCULATION ---
                float falloff = spotFalloff(L);
                
                // Si estamos fuera del cono, la luz es casi nula (solo ambiente)
                if (falloff == 0.0) {
                     fragColor = vec4(ambient, 1.0);
                     return;
                }

                // --- SHADOW MAPPING: Conversión de coordenadas de la luz ---
                vec3 projCoords = v_lightSpacePos.xyz / v_lightSpacePos.w;
                projCoords = projCoords * 0.5 + 0.5; // Mapeo a [0, 1]
                
                // Si projCoords.w es negativo o cero, el fragmento está detrás de la luz (no debería suceder con perspectiva)
                if (v_lightSpacePos.w <= 0.0) {
                    fragColor = vec4(ambient, 1.0);
                    return;
                }

                // --- CÁLCULO DE SOMBRAS ---
                float shadow = calculateShadow(projCoords); 
                
                // --- ILUMINACIÓN DIFUSA Y ESPECULAR ---
                
                // Atenuación basada en la distancia (cuadrática simple)
                float attenuation = 1.0 / (1.0 + 0.01 * distance * distance); 

                // Difusa
                float diff = max(dot(normal, L), 0.0);
                vec3 diffuse = diff * u_objectColor;

                // Especular
                vec3 viewDir = normalize(u_viewPos - v_worldPos);
                vec3 reflectDir = reflect(-L, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = spec * vec3(0.5); 
                
                // Mezcla de colores (sombra = 1.0 es sombreado, 0.0 es iluminado)
                // Aplicamos la atenuación y el falloff de la luz solo a los componentes directo (difuso + especular)
                vec3 lighting = (diffuse + specular) * attenuation * falloff;
                
                // La parte sombreada recibe solo un 50% de la luz directa.
                vec3 finalColor = ambient + (1.0 - shadow * 0.5) * lighting;
                
                fragColor = vec4(finalColor, 1.0);
            }
        `;

        // =====================================================================
        // UTILIDADES Y MATEMÁTICAS (Implementación mínima de vec3 y mat4)
        // =====================================================================

        function normalize(v) {
            const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / length, v[1] / length, v[2] / length];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function identity() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        function multiply(a, b) {
            const c = new Array(16).fill(0);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    for (let k = 0; k < 4; k++) {
                        c[i * 4 + j] += a[k * 4 + j] * b[i * 4 + k];
                    }
                }
            }
            return c;
        }

        function translate(m, v) {
            let m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
            let m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
            let m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
            let m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
            m[12] = m00 * v[0] + m10 * v[1] + m20 * v[2] + m30;
            m[13] = m01 * v[0] + m11 * v[1] + m21 * v[2] + m31;
            m[14] = m02 * v[0] + m12 * v[1] + m22 * v[2] + m32;
            m[15] = m03 * v[0] + m13 * v[1] + m23 * v[2] + m33;
            return m;
        }

        // Matriz de Perspectiva (Projection)
        function perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const rangeInv = 1.0 / (near - far);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, 2 * near * far * rangeInv, 0
            ];
        }

        // Matriz LookAt (View)
        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);

            return [
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]),
                -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]),
                -(z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2]),
                1
            ];
        }

        // =====================================================================
        // FUNCIONES DE COMPILACIÓN Y GEOMETRÍA (Se mantienen como antes)
        // =====================================================================

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ERROR linking program:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Genera vértices, normales e índices de un cubo
        function createCubeGeometry(size) {
            const h = size / 2.0;
            const positions = new Float32Array([
                -h, -h, h,  h, -h, h,  h, h, h,  -h, h, h, 
                -h, -h, -h, -h, h, -h,  h, h, -h,  h, -h, -h,
                -h, h, h,  h, h, h,  h, h, -h,  -h, h, -h,
                -h, -h, h,  -h, -h, -h,  h, -h, -h,  h, -h, h,
                h, -h, h,  h, -h, -h,  h, h, -h,  h, h, h,
                -h, -h, h,  -h, h, h,  -h, h, -h,  -h, -h, -h,
            ]);
            const normals = new Float32Array([
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
            ]);
            const indices = new Uint16Array([
                0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 
                12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23, 
            ]);
            return { positions, normals, indices };
        }

        // Genera vértices y normales de una esfera
        function createSphereGeometry(radius, latSegments = 30, longSegments = 30) {
            const positions = [];
            const normals = [];
            const indices = [];
            for (let i = 0; i <= latSegments; i++) {
                const latAngle = i * Math.PI / latSegments;
                const sinLat = Math.sin(latAngle);
                const cosLat = Math.cos(latAngle);
                for (let j = 0; j <= longSegments; j++) {
                    const longAngle = j * 2 * Math.PI / longSegments;
                    const sinLong = Math.sin(longAngle);
                    const cosLong = Math.cos(longAngle);
                    const x = radius * cosLong * sinLat;
                    const y = radius * cosLat;
                    const z = radius * sinLong * sinLat;
                    positions.push(x, y, z);
                    normals.push(x / radius, y / radius, z / radius);
                    if (i < latSegments && j < longSegments) {
                        const first = i * (longSegments + 1) + j;
                        const second = first + longSegments + 1;
                        indices.push(first, second, first + 1, second, second + 1, first + 1);
                    }
                }
            }
            return { positions: new Float32Array(positions), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }
        
        // Genera vértices y normales de un plano (grid)
        function createGridGeometry(size, segments = 50) {
            const h = size / 2.0;
            const step = size / segments;
            const positions = [];
            const normals = [];
            const indices = [];
            let v = 0;
            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    positions.push(-h + i * step, 0.0, -h + j * step);
                    normals.push(0.0, 1.0, 0.0);
                    if (i < segments && j < segments) {
                        const a = v;
                        const b = v + 1;
                        const c = v + segments + 1;
                        const d = v + segments + 2;
                        indices.push(a, d, c, a, b, d);
                    }
                    v++;
                }
            }
            return { positions: new Float32Array(positions), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }


        // Función genérica para crear y enlazar VAO/VBOs
        function createVAO(gl, geometry) {
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            // Buffer de Posiciones (location = 0)
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            // Buffer de Normales (location = 1)
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.normals, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

            // Buffer de Índices
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.indices, gl.STATIC_DRAW);

            gl.bindVertexArray(null);

            return { vao, numElements: geometry.indices.length };
        }

        // =====================================================================
        // CONFIGURACIÓN INICIAL DE WEBGL2
        // =====================================================================

        function resizeCanvas() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            GL.viewport(0, 0, CANVAS.width, CANVAS.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Compilar programas
        const shadowProgram = createProgram(GL, SHADOW_VS_SOURCE, SHADOW_FS_SOURCE);
        const sceneProgram = createProgram(GL, SCENE_VS_SOURCE, SCENE_FS_SOURCE);

        // Obtener ubicaciones de uniforms
        const uniforms = {
            shadow: {
                lightMatrix: GL.getUniformLocation(shadowProgram, 'u_lightMatrix'),
            },
            scene: {
                model: GL.getUniformLocation(sceneProgram, 'u_model'),
                view: GL.getUniformLocation(sceneProgram, 'u_view'),
                projection: GL.getUniformLocation(sceneProgram, 'u_projection'),
                lightViewProjection: GL.getUniformLocation(sceneProgram, 'u_lightViewProjection'),
                
                // Uniforms de la Spot Light
                lightPos: GL.getUniformLocation(sceneProgram, 'u_lightPos'),
                lightDir: GL.getUniformLocation(sceneProgram, 'u_lightDir'),
                innerCone: GL.getUniformLocation(sceneProgram, 'u_innerCone'),
                outerCone: GL.getUniformLocation(sceneProgram, 'u_outerCone'),

                viewPos: GL.getUniformLocation(sceneProgram, 'u_viewPos'),
                objectColor: GL.getUniformLocation(sceneProgram, 'u_objectColor'),
                shadowMap: GL.getUniformLocation(sceneProgram, 'u_shadowMap'),
            }
        };

        // Crear geometría y VAOs
        const gridGeo = createGridGeometry(GRID_SIZE);
        const sphereGeo = createSphereGeometry(SPHERE_RADIUS);
        const cubeGeo = createCubeGeometry(CUBE_SIZE);

        const gridVAO = createVAO(GL, gridGeo);
        const sphereVAO = createVAO(GL, sphereGeo);
        const cubeVAO = createVAO(GL, cubeGeo);

        // Model matrices
        const gridModel = identity(); 
        
        let sphereModel = identity();
        sphereModel = translate(sphereModel, SPHERE_POS); 

        let cubeModel = identity();
        cubeModel = translate(cubeModel, CUBE_POS); 

        // Arreglo de objetos para iterar
        const renderObjects = [
            // El grid es grande para demostrar la Spot Light
            { vao: gridVAO.vao, count: gridVAO.numElements, model: gridModel, color: [0.2, 0.5, 0.2] }, 
            { vao: sphereVAO.vao, count: sphereVAO.numElements, model: sphereModel, color: [0.9, 0.2, 0.2] }, 
            { vao: cubeVAO.vao, count: cubeVAO.numElements, model: cubeModel, color: [0.2, 0.2, 0.9] }, 
        ];

        // =====================================================================
        // CONFIGURACIÓN DE SHADOW MAPPING (FBO y Textura)
        // =====================================================================

        // 1. Crear Textura de Profundidad (Shadow Map)
        const shadowMap = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, shadowMap);
        GL.texImage2D(GL.TEXTURE_2D, 0, GL.DEPTH_COMPONENT16, SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, 0, GL.DEPTH_COMPONENT, GL.UNSIGNED_INT, null);

        // Parámetros de la textura
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR); // Linear para mejor calidad
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);

        // 2. Crear Framebuffer Object (FBO)
        const shadowFBO = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, shadowFBO);

        // Adjuntar la textura de profundidad al FBO
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.DEPTH_ATTACHMENT, GL.TEXTURE_2D, shadowMap, 0);

        // Indicar a WebGL que no necesitamos una salida de color
        GL.drawBuffers([GL.NONE]);
        GL.readBuffer(GL.NONE);

        if (GL.checkFramebufferStatus(GL.FRAMEBUFFER) !== GL.FRAMEBUFFER_COMPLETE) {
            console.error('Framebuffer no está completo!');
        }

        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
        GL.bindTexture(GL.TEXTURE_2D, null);

        // =====================================================================
        // CÁLCULO DE MATRICES DE LUZ (Perspectiva para Spot Light)
        // =====================================================================

        // El FOV de la luz es el doble del ángulo exterior del cono
        const LIGHT_FOV = 40.0 * Math.PI / 180.0; 
        const LIGHT_NEAR = 0.5;
        const LIGHT_FAR = 40.0; // Suficiente para cubrir los objetos desde LIGHT_POS

        // Matriz de Proyección (Perspectiva) para la Spot Light
        const lightProjection = perspective(LIGHT_FOV, 1.0, LIGHT_NEAR, LIGHT_FAR);

        // Matriz de Vista de la Luz (LookAt desde la luz hacia el target)
        const lightView = lookAt(LIGHT_POS, LIGHT_TARGET, [0, 1, 0]);

        // Matriz combinada P_light * V_light
        const lightViewProjectionMatrix = multiply(lightProjection, lightView);

        // =====================================================================
        // BUCLE DE RENDERIZADO
        // =====================================================================

        function drawScene(program, lightPass) {
            GL.useProgram(program);
            
            if (lightPass) {
                // Paso de Profundidad: solo necesitamos la matriz de la luz
                GL.uniformMatrix4fv(uniforms.shadow.lightMatrix, false, lightViewProjectionMatrix);
            } 
            else {
                // Paso de Renderizado Principal: configurar todas las matrices y uniforms
                const aspectRatio = CANVAS.width / CANVAS.height;
                const projectionMatrix = perspective(FOV, aspectRatio, NEAR, FAR);
                const viewMatrix = lookAt(CAMERA_POS, CAMERA_TARGET, [0, 1, 0]);
                
                GL.uniformMatrix4fv(uniforms.scene.view, false, viewMatrix);
                GL.uniformMatrix4fv(uniforms.scene.projection, false, projectionMatrix);
                GL.uniformMatrix4fv(uniforms.scene.lightViewProjection, false, lightViewProjectionMatrix);
                
                // Uniforms de la luz
                GL.uniform3fv(uniforms.scene.lightPos, LIGHT_POS);
                GL.uniform3fv(uniforms.scene.lightDir, LIGHT_DIRECTION);
                GL.uniform1f(uniforms.scene.innerCone, INNER_CONE);
                GL.uniform1f(uniforms.scene.outerCone, OUTER_CONE);

                GL.uniform3fv(uniforms.scene.viewPos, CAMERA_POS);
                
                // Enlazar el Shadow Map a la textura 0
                GL.activeTexture(GL.TEXTURE0);
                GL.bindTexture(GL.TEXTURE_2D, shadowMap);
                GL.uniform1i(uniforms.scene.shadowMap, 0); 
            }

            // Dibujar cada objeto
            renderObjects.forEach(obj => {
                GL.bindVertexArray(obj.vao);
                
                // Aplicar Model Matrix y Color
                GL.uniformMatrix4fv(lightPass ? uniforms.shadow.lightMatrix : uniforms.scene.model, false, obj.model);
                if (!lightPass) {
                    GL.uniform3fv(uniforms.scene.objectColor, obj.color);
                }

                GL.drawElements(GL.TRIANGLES, obj.count, GL.UNSIGNED_SHORT, 0);
            });

            GL.bindVertexArray(null);
        }


        function render() {
            // --- PASO 1: GENERAR EL MAPA DE SOMBRAS (Profundidad) ---
            
            GL.bindFramebuffer(GL.FRAMEBUFFER, shadowFBO);
            GL.viewport(0, 0, SHADOW_MAP_SIZE, SHADOW_MAP_SIZE);
            
            // CRÍTICO: SOLO limpiar el buffer de profundidad, no el de color.
            GL.clear(GL.DEPTH_BUFFER_BIT); 
            GL.enable(GL.DEPTH_TEST);
            GL.cullFace(GL.FRONT); // Optimización: Culling de caras frontales para reducir Shadow Acne (opcional)
            
            drawScene(shadowProgram, true);

            // --- PASO 2: RENDERIZAR LA ESCENA CON ILUMINACIÓN Y SOMBRAS ---

            GL.bindFramebuffer(GL.FRAMEBUFFER, null); 
            GL.viewport(0, 0, CANVAS.width, CANVAS.height);
            
            GL.clearColor(0.2, 0.2, 0.2, 1.0);
            GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
            GL.cullFace(GL.BACK); // Volver al culling normal
            
            drawScene(sceneProgram, false);

            requestAnimationFrame(render);
        }

        // Inicializar el bucle de renderizado
        requestAnimationFrame(render);

    </script>
</body>
</html>