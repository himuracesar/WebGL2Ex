<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 Stencil Outline - Smooth Edges Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #eee; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        .key { color: #0af; font-weight: bold; }
        .fix { color: #0f0; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>WebGL2: Outline con Bordes Suaves</h2>
        <p>Técnica: <span class="key">Stencil Mask + Vertex Extrusion</span></p>
        <p>Solución aplicada: <span class="fix">Averaged Normals (Suavizado)</span></p>
        <p><small>Las aristas del cubo ahora son continuas.</small></p>
    </div>
    <canvas id="gl-canvas"></canvas>

    <script id="vs-basic" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;
        uniform mat4 u_projection, u_view, u_model;
        out vec3 v_normal;
        void main() {
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
        }
    </script>
    <script id="fs-basic" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_normal;
        out vec4 outColor;
        uniform vec3 u_color;
        void main() {
            vec3 lightDir = normalize(vec3(0.5, 1.0, 0.7));
            float diff = max(dot(normalize(v_normal), lightDir), 0.2);
            outColor = vec4(u_color * diff, 1.0);
        }
    </script>
    <script id="vs-outline" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal; // ¡Ahora recibe normales suaves!
        uniform mat4 u_projection, u_view, u_model;
        uniform float u_thickness;
        void main() {
            // Extrusión usando la normal promediada
            vec3 expandedPos = a_position + (a_normal * u_thickness);
            gl_Position = u_projection * u_view * u_model * vec4(expandedPos, 1.0);
        }
    </script>
    <script id="fs-outline" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() { outColor = vec4(1.0, 0.5, 0.0, 1.0); }
    </script>

    <script>
        "use strict";

        // --- MATH LIBRARY ---
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (fovy, aspect, near, far) => {
                let f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
            },
            lookAt: (eye, center, up) => {
                let z = normalize(subtract(eye, center)), x = normalize(cross(up, z)), y = cross(z, x);
                return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
            },
            translate: (m, v) => {
                m[12] += m[0]*v[0] + m[4]*v[1] + m[8]*v[2];
                m[13] += m[1]*v[0] + m[5]*v[1] + m[9]*v[2];
                m[14] += m[2]*v[0] + m[6]*v[1] + m[10]*v[2];
                m[15] += m[3]*v[0] + m[7]*v[1] + m[11]*v[2];
                return m;
            }
        };
        const subtract = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
        const cross = (a, b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        const normalize = (a) => {
            let l = 1/Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);
            return [a[0]*l, a[1]*l, a[2]*l];
        };
        const dot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];

        // --- GEOMETRY GENERATORS ---
        
        // NUEVA FUNCIÓN: Calcula normales suaves promediando caras adyacentes
        function calculateSmoothNormals(pos, idx) {
            const smoothNormals = new Float32Array(pos.length).fill(0);
            
            // Iterar sobre cada triángulo
            for (let i = 0; i < idx.length; i += 3) {
                const i0 = idx[i] * 3, i1 = idx[i+1] * 3, i2 = idx[i+2] * 3;
                const p0 = [pos[i0], pos[i0+1], pos[i0+2]];
                const p1 = [pos[i1], pos[i1+1], pos[i1+2]];
                const p2 = [pos[i2], pos[i2+1], pos[i2+2]];
                
                // Calcular normal de la cara
                const v0 = subtract(p1, p0);
                const v1 = subtract(p2, p0);
                const faceNormal = normalize(cross(v0, v1));
                
                // Acumular la normal de la cara en cada vértice del triángulo
                for (let j = 0; j < 3; j++) {
                    smoothNormals[i0+j] += faceNormal[j];
                    smoothNormals[i1+j] += faceNormal[j];
                    smoothNormals[i2+j] += faceNormal[j];
                }
            }
            
            // Normalizar el resultado acumulado para cada vértice
            for (let i = 0; i < smoothNormals.length; i += 3) {
                const n = normalize([smoothNormals[i], smoothNormals[i+1], smoothNormals[i+2]]);
                smoothNormals[i] = n[0]; smoothNormals[i+1] = n[1]; smoothNormals[i+2] = n[2];
            }
            
            return smoothNormals;
        }

        function createCube(size) {
            let s = size / 2;
            // Vértices únicos (no duplicados por cara) para que el suavizado funcione bien
            const pos = new Float32Array([
                -s,-s, s,  s,-s, s,  s, s, s, -s, s, s, // Front
                -s,-s,-s, -s, s,-s,  s, s,-s,  s,-s,-s  // Back
            ]);
            // Índices para formar los triángulos usando los 8 vértices únicos
            const idx = new Uint16Array([
                0,1,2, 0,2,3, // Front
                4,5,6, 4,6,7, // Back
                4,0,3, 4,3,5, // Left
                1,7,6, 1,6,2, // Right
                3,2,6, 3,6,5, // Top
                4,7,1, 4,1,0  // Bottom
            ]);

            // APLICAMOS EL FIX: Calcular normales suaves
            const smoothNorm = calculateSmoothNormals(pos, idx);

            // Para el render normal (flat shading), necesitaríamos las normales originales duplicadas.
            // Para este ejemplo, usaremos las suaves para TODO, lo que hará que el cubo se vea "redondeado"
            // pero el outline será perfecto. En un motor real, tendrías dos sets de normales.
            return { pos, norm: smoothNorm, idx };
        }

        // (El resto de la generación de geometría y grid se omite por brevedad, es igual al anterior)
        function createGrid(size, steps) { let pos = [], half = size / 2; for(let i=0; i<=steps; i++) { let x = (i / steps) * size - half; pos.push(x, 0, -half, x, 0, half, -half, 0, x, half, 0, x); } return new Float32Array(pos); }

        /**
         * MAIN APPLICATION
         */
        async function init() {
            const canvas = document.getElementById("gl-canvas");
            const gl = canvas.getContext("webgl2", { stencil: true, antialias: true });
            if (!gl) return console.error("WebGL2 not supported");

            // (Funciones createShader y createProgram omitidas, son iguales)
            function createShader(gl, type, source) { const s = gl.createShader(type); gl.shaderSource(s, source); gl.compileShader(s); if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
            function createProgram(gl, vsSrc, fsSrc) { const p = gl.createProgram(); gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vsSrc)); gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fsSrc)); gl.linkProgram(p); if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p; }

            const progBasic = createProgram(gl, document.getElementById("vs-basic").text, document.getElementById("fs-basic").text);
            const progOutline = createProgram(gl, document.getElementById("vs-outline").text, document.getElementById("fs-outline").text);

            const locations = {
                basic: { 
                    uProj: gl.getUniformLocation(progBasic, "u_projection"), uView: gl.getUniformLocation(progBasic, "u_view"), uModel: gl.getUniformLocation(progBasic, "u_model"), uColor: gl.getUniformLocation(progBasic, "u_color") },
                outline: { 
                    uProj: gl.getUniformLocation(progOutline, "u_projection"), uView: gl.getUniformLocation(progOutline, "u_view"), uModel: gl.getUniformLocation(progOutline, "u_model"), uThickness: gl.getUniformLocation(progOutline, "u_thickness") }
            };

            function setupVAO(data, hasNormals = true) {
                const vao = gl.createVertexArray(); 
                
                gl.bindVertexArray(vao);
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); 
                gl.bufferData(gl.ARRAY_BUFFER, data.pos, gl.STATIC_DRAW); 
                gl.enableVertexAttribArray(0); 
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                if(hasNormals) { 
                    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); 
                    gl.bufferData(gl.ARRAY_BUFFER, data.norm, gl.STATIC_DRAW); 
                    gl.enableVertexAttribArray(1); 
                    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0); 
                }

                if(data.idx) { 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); 
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.idx, gl.STATIC_DRAW); 
                }

                gl.bindVertexArray(null); 
                
                return vao;
            }

            // Usamos el nuevo cubo con normales suaves
            const cubeGeo = createCube(25);
            const gridData = createGrid(200, 20);

            const vaoCube = setupVAO(cubeGeo);
            const vaoGrid = setupVAO({ pos: gridData }, false);

            function render(time) {
                time *= 0.001;
                gl.viewport(0, 0, canvas.width, canvas.height);
                
                // IMPORTANTE: Limpiar Color, Depth y STENCIL
                gl.clearColor(0.4, 0.6, 0.9, 1.0); // Color de fondo azul cielo
                gl.stencilMask(0xFF); // Asegurar escritura para el clear
                gl.clearStencil(0); 
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                gl.enable(gl.DEPTH_TEST);

                const aspect = canvas.width / canvas.height;
                const proj = mat4.perspective(Math.PI / 4, aspect, 0.1, 1000);
                const view = mat4.lookAt([40, 40, 60], [0, 0, 0], [0, 1, 0]); // Cámara elevada

                // 1. DIBUJAR GRID
                gl.useProgram(progBasic);
                gl.uniformMatrix4fv(locations.basic.uProj, false, proj);
                gl.uniformMatrix4fv(locations.basic.uView, false, view);
                gl.uniformMatrix4fv(locations.basic.uModel, false, mat4.identity());
                gl.uniform3f(locations.basic.uColor, 0.3, 0.3, 0.3);
                gl.bindVertexArray(vaoGrid);
                gl.drawArrays(gl.LINES, 0, gridData.length / 3);

                // --- TÉCNICA DE STENCIL OUTLINE PARA EL CUBO ---

                // PASO A: Configurar el Stencil Buffer y dibujar el objeto
                gl.enable(gl.STENCIL_TEST);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
                gl.stencilMask(0xFF);

                let modelCube = mat4.identity(); // Cubo centrado
                gl.uniformMatrix4fv(locations.basic.uModel, false, modelCube);
                gl.uniform3f(locations.basic.uColor, 0.7, 0.7, 0.7); // Cubo gris
                gl.bindVertexArray(vaoCube);
                gl.drawElements(gl.TRIANGLES, cubeGeo.idx.length, gl.UNSIGNED_SHORT, 0);

                // PASO B: Renderizar el Outline
                gl.stencilFunc(gl.NOTEQUAL, 1, 0xFF);
                gl.stencilMask(0x00);
                gl.disable(gl.DEPTH_TEST);

                gl.useProgram(progOutline);
                gl.uniformMatrix4fv(locations.outline.uProj, false, proj);
                gl.uniformMatrix4fv(locations.outline.uView, false, view);
                gl.uniformMatrix4fv(locations.outline.uModel, false, modelCube);
                gl.uniform1f(locations.outline.uThickness, 1.0); // Grosor del borde

                gl.drawElements(gl.TRIANGLES, cubeGeo.idx.length, gl.UNSIGNED_SHORT, 0);

                // Limpieza de estado
                gl.disable(gl.STENCIL_TEST);
                gl.enable(gl.DEPTH_TEST);

                requestAnimationFrame(render);
            }

            function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
            window.addEventListener('resize', resize); resize();
            requestAnimationFrame(render);
        }

        init();
    </script>
</body>
</html>