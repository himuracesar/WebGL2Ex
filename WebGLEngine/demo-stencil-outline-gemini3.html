<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 Stencil Outline - Pure JS Expert Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #eee; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; text-shadow: 1px 1px 2px #000; }
        .key { color: #0af; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>WebGL2: Control de Stencil Buffer</h2>
        <p>Esfera: <span class="key">Stencil Mask + Outline Pass</span></p>
        <p>Cubo: <span class="key">Standard Pass</span></p>
        <p>API: <span class="key">Web Graphics Library 2.0 (Pure JS)</span></p>
    </div>
    <canvas id="gl-canvas"></canvas>

    <script id="vs-basic" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_model;
        
        out vec3 v_normal;

        void main() {
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
        }
    </script>

    <script id="fs-basic" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        
        in vec3 v_normal;
        out vec4 outColor;

        uniform vec3 u_color;

        void main() {
            vec3 lightDir = normalize(vec3(0.5, 1.0, 0.7));
            float diff = max(dot(normalize(v_normal), lightDir), 0.2);
            outColor = vec4(u_color * diff, 1.0);
        }
    </script>

    <script id="vs-outline" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_model;
        uniform float u_thickness;

        void main() {
            // Expansión a lo largo de la normal en el Vertex Shader
            // para crear el efecto de borde uniforme
            vec3 expandedPos = a_position + (a_normal * u_thickness);
            gl_Position = u_projection * u_view * u_model * vec4(expandedPos, 1.0);
        }
    </script>

    <script id="fs-outline" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() {
            outColor = vec4(1.0, 0.5, 0.0, 1.0); // Borde naranja brillante
        }
    </script>

    <script>
        "use strict";

        /**
         * MATH LIBRARY (Minimal mat4 implementation)
         */
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (fovy, aspect, near, far) => {
                let f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
            },
            lookAt: (eye, center, up) => {
                let z = normalize(subtract(eye, center)), x = normalize(cross(up, z)), y = cross(z, x);
                return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
            },
            translate: (m, v) => {
                m[12] += m[0]*v[0] + m[4]*v[1] + m[8]*v[2];
                m[13] += m[1]*v[0] + m[5]*v[1] + m[9]*v[2];
                m[14] += m[2]*v[0] + m[6]*v[1] + m[10]*v[2];
                m[15] += m[3]*v[0] + m[7]*v[1] + m[11]*v[2];
                return m;
            }
        };
        const subtract = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
        const cross = (a, b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        const normalize = (a) => {
            let l = 1/Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);
            return [a[0]*l, a[1]*l, a[2]*l];
        };
        const dot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];

        /**
         * GEOMETRY GENERATORS
         */
        function createSphere(radius, segments) {
            let pos = [], norm = [], idx = [];
            for(let y=0; y<=segments; y++) {
                let lat = y * Math.PI / segments, sinLat = Math.sin(lat), cosLat = Math.cos(lat);
                for(let x=0; x<=segments; x++) {
                    let lon = x * 2 * Math.PI / segments, sinLon = Math.sin(lon), cosLon = Math.cos(lon);
                    let ux = cosLon * sinLat, uy = cosLat, uz = sinLon * sinLat;
                    pos.push(radius * ux, radius * uy, radius * uz);
                    norm.push(ux, uy, uz);
                }
            }
            for(let y=0; y<segments; y++) {
                for(let x=0; x<segments; x++) {
                    let first = (y * (segments + 1)) + x, second = first + segments + 1;
                    idx.push(first, second, first + 1, second, second + 1, first + 1);
                }
            }
            return { pos: new Float32Array(pos), norm: new Float32Array(norm), idx: new Uint16Array(idx) };
        }

        function createCube(size) {
            let s = size / 2;
            const pos = new Float32Array([
                -s,-s, s, s,-s, s, s, s, s, -s, s, s, -s,-s,-s, -s, s,-s, s, s,-s, s,-s,-s,
                -s, s,-s, -s, s, s, s, s, s, s, s,-s, -s,-s,-s, s,-s,-s, s,-s, s, -s,-s, s,
                 s,-s,-s, s, s,-s, s, s, s, s,-s, s, -s,-s,-s, -s,-s, s, -s, s, s, -s, s,-s
            ]);
            const norm = new Float32Array([
                0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
                0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
                1,0,0, 1,0,0, 1,0,0, 1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0
            ]);
            const idx = new Uint16Array([
                0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
            ]);
            return { pos, norm, idx };
        }

        function createGrid(size, steps) {
            let pos = [];
            let half = size / 2;
            for(let i=0; i<=steps; i++) {
                let x = (i / steps) * size - half;
                pos.push(x, 0, -half, x, 0, half);
                pos.push(-half, 0, x, half, 0, x);
            }
            return new Float32Array(pos);
        }

        /**
         * MAIN APPLICATION
         */
        async function init() {
            const canvas = document.getElementById("gl-canvas");
            const gl = canvas.getContext("webgl2", { stencil: true, antialias: true });
            if (!gl) return console.error("WebGL2 not supported");

            function createShader(gl, type, source) {
                const s = gl.createShader(type);
                gl.shaderSource(s, source);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
                return s;
            }

            function createProgram(gl, vsSrc, fsSrc) {
                const p = gl.createProgram();
                gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vsSrc));
                gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fsSrc));
                gl.linkProgram(p);
                if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
                return p;
            }

            // Init Programs
            const progBasic = createProgram(gl, document.getElementById("vs-basic").text, document.getElementById("fs-basic").text);
            const progOutline = createProgram(gl, document.getElementById("vs-outline").text, document.getElementById("fs-outline").text);

            const locations = {
                basic: {
                    uProj: gl.getUniformLocation(progBasic, "u_projection"),
                    uView: gl.getUniformLocation(progBasic, "u_view"),
                    uModel: gl.getUniformLocation(progBasic, "u_model"),
                    uColor: gl.getUniformLocation(progBasic, "u_color")
                },
                outline: {
                    uProj: gl.getUniformLocation(progOutline, "u_projection"),
                    uView: gl.getUniformLocation(progOutline, "u_view"),
                    uModel: gl.getUniformLocation(progOutline, "u_model"),
                    uThickness: gl.getUniformLocation(progOutline, "u_thickness")
                }
            };

            // Init Geometry VAOs
            function setupVAO(data, hasNormals = true) {
                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);
                
                const pBuf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, pBuf);
                gl.bufferData(gl.ARRAY_BUFFER, data.pos, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                if(hasNormals) {
                    const nBuf = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, nBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, data.norm, gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
                }

                if(data.idx) {
                    const iBuf = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuf);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.idx, gl.STATIC_DRAW);
                }
                
                gl.bindVertexArray(null);
                return vao;
            }

            const sphereGeo = createSphere(25, 32);
            const cubeGeo = createCube(25);
            const gridData = createGrid(200, 20);

            const vaoSphere = setupVAO(sphereGeo);
            const vaoCube = setupVAO(cubeGeo);
            const vaoGrid = setupVAO({ pos: gridData }, false);

            function render(time) {
                time *= 0.001;
                gl.viewport(0, 0, canvas.width, canvas.height);
                
                // IMPORTANTE: Limpiar Color, Depth y STENCIL
                gl.clearColor(0.05, 0.05, 0.05, 1.0);
                gl.clearStencil(0); 
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                gl.enable(gl.DEPTH_TEST);

                const aspect = canvas.width / canvas.height;
                const proj = mat4.perspective(Math.PI / 4, aspect, 0.1, 1000);
                const view = mat4.lookAt([0, 80, 150], [0, 0, 0], [0, 1, 0]);

                // 1. DIBUJAR GRID
                gl.useProgram(progBasic);
                gl.uniformMatrix4fv(locations.basic.uProj, false, proj);
                gl.uniformMatrix4fv(locations.basic.uView, false, view);
                gl.uniformMatrix4fv(locations.basic.uModel, false, mat4.identity());
                gl.uniform3f(locations.basic.uColor, 0.3, 0.3, 0.3);
                gl.bindVertexArray(vaoGrid);
                gl.drawArrays(gl.LINES, 0, gridData.length / 3);

                // 2. DIBUJAR CUBO (Sin Stencil)
                let modelCube = mat4.translate(mat4.identity(), [25, 12.5, 0]);
                gl.uniformMatrix4fv(locations.basic.uModel, false, modelCube);
                gl.uniform3f(locations.basic.uColor, 0.2, 0.5, 0.8);
                gl.bindVertexArray(vaoCube);
                gl.drawElements(gl.TRIANGLES, cubeGeo.idx.length, gl.UNSIGNED_SHORT, 0);

                // --- TÉCNICA DE STENCIL OUTLINE PARA LA ESFERA ---

                // PASO A: Configurar el Stencil Buffer para escribir
                gl.enable(gl.STENCIL_TEST);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE); // Reemplazar con Ref si pasa el test
                gl.stencilFunc(gl.ALWAYS, 1, 0xFF);         // Siempre pasa, escribe un '1'
                gl.stencilMask(0xFF);                       // Habilitar escritura

                let modelSphere = mat4.translate(mat4.identity(), [-25, 25, 0]);
                gl.uniformMatrix4fv(locations.basic.uModel, false, modelSphere);
                gl.uniform3f(locations.basic.uColor, 0.8, 0.2, 0.2);
                gl.bindVertexArray(vaoSphere);
                
                // Renderizamos la esfera normal (esto llena el Stencil Buffer con 1s en su silueta)
                gl.drawElements(gl.TRIANGLES, sphereGeo.idx.length, gl.UNSIGNED_SHORT, 0);

                // PASO B: Renderizar el Outline
                // Solo dibujamos donde el valor del stencil NO SEA 1 (fuera de la esfera original)
                gl.stencilFunc(gl.NOTEQUAL, 1, 0xFF);
                gl.stencilMask(0x00); // Deshabilitar escritura en stencil para no ensuciar
                gl.disable(gl.DEPTH_TEST); // Opcional: permite ver el borde incluso si algo lo ocluye ligeramente

                gl.useProgram(progOutline);
                gl.uniformMatrix4fv(locations.outline.uProj, false, proj);
                gl.uniformMatrix4fv(locations.outline.uView, false, view);
                gl.uniformMatrix4fv(locations.outline.uModel, false, modelSphere);
                gl.uniform1f(locations.outline.uThickness, 1.2); // Grosor del borde en unidades

                gl.drawElements(gl.TRIANGLES, sphereGeo.idx.length, gl.UNSIGNED_SHORT, 0);

                // Limpieza de estado para el siguiente frame
                gl.disable(gl.STENCIL_TEST);
                gl.enable(gl.DEPTH_TEST);

                requestAnimationFrame(render);
            }

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resize);
            resize();
            requestAnimationFrame(render);
        }

        init();
    </script>
</body>
</html>