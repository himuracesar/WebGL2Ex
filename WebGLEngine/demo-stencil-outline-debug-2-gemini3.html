<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>WebGL2 Multi-ID Stencil - Expert Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #eee; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.85); padding: 20px; border-radius: 4px; border-left: 5px solid #0af; }
        .label { display: inline-block; width: 120px; font-weight: bold; }
        .sphere { color: #ff00ff; } /* Magenta */
        .cube { color: #00ffff; }   /* Cyan */
    </style>
</head>
<body>
    <div id="ui">
        <h3 style="margin-top:0"> INSPECTOR DE STENCIL V2.0</h3>
        <p><span class="label">OBJETO A:</span> Esfera <span class="sphere">(Stencil REF 1)</span></p>
        <p><span class="label">OBJETO B:</span> Cubo   <span class="cube">(Stencil REF 2)</span></p>
        <hr style="border:0; border-top:1px solid #444">
        <p><small>Visualizando máscaras mediante Full-Screen Quad Multipass</small></p>
    </div>
    <canvas id="gl-canvas"></canvas>

    <script id="vs-basic" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec3 a_position;
        layout(location = 1) in vec3 a_normal;
        uniform mat4 u_proj, u_view, u_model;
        out vec3 v_normal;
        void main() {
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_proj * u_view * u_model * vec4(a_position, 1.0);
        }
    </script>

    <script id="fs-basic" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_normal;
        out vec4 outColor;
        uniform vec3 u_color;
        void main() {
            float d = max(dot(normalize(v_normal), normalize(vec3(1,1,1))), 0.2);
            outColor = vec4(u_color * d, 1.0);
        }
    </script>

    <script id="vs-debug" type="x-shader/x-vertex">#version 300 es
        layout(location = 0) in vec2 a_pos;
        void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
    </script>

    <script id="fs-debug" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        out vec4 outColor;
        uniform vec4 u_debugColor;
        void main() { outColor = u_debugColor; }
    </script>

    <script>
        "use strict";

        // --- MATH UTILS ---
        const mat4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (fovy, aspect, near, far) => {
                let f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
            },
            lookAt: (eye, center, up) => {
                const normalize = (v) => { let l = 1/Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]*l,v[1]*l,v[2]*l]; };
                const cross = (a,b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
                const dot = (a,b) => a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
                const z = normalize([eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]]);
                const x = normalize(cross(up, z)), y = cross(z, x);
                return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
            },
            translate: (m, v) => { m[12]+=v[0]; m[13]+=v[1]; m[14]+=v[2]; return m; }
        };

        // --- GEOMETRY ---
        function getSphere(r, s) {
            let p=[], n=[], idx=[];
            for(let y=0; y<=s; y++){
                let lat=y*Math.PI/s, sl=Math.sin(lat), cl=Math.cos(lat);
                for(let x=0; x<=s; x++){
                    let lon=x*2*Math.PI/s, ux=Math.cos(lon)*sl, uy=cl, uz=Math.sin(lon)*sl;
                    p.push(r*ux,r*uy,r*uz); n.push(ux,uy,uz);
                }
            }
            for(let y=0; y<s; y++) for(let x=0; x<s; x++){
                let f=y*(s+1)+x, sec=f+s+1; idx.push(f,sec,f+1,sec,sec+1,f+1);
            }
            return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) };
        }

        function getCube(s) {
            let h=s/2;
            let p = new Float32Array([-h,-h,h, h,-h,h, h,h,h, -h,h,h, -h,-h,-h, -h,h,-h, h,h,-h, h,-h,-h, -h,h,-h, -h,h,h, h,h,h, h,h,-h, -h,-h,-h, h,-h,-h, h,-h,h, -h,-h,h, h,-h,-h, h,h,-h, h,h,h, h,-h,h, -h,-h,-h, -h,-h,h, -h,h,h, -h,h,-h]);
            let n = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0]);
            let i = new Uint16Array([0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23]);
            return { p, n, i };
        }

        async function main() {
            const canvas = document.getElementById("gl-canvas");
            const gl = canvas.getContext("webgl2", { stencil: true });

            const createP = (vsId, fsId) => {
                const p = gl.createProgram();
                [vsId, fsId].forEach((id, i) => {
                    const s = gl.createShader(i ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER);
                    gl.shaderSource(s, document.getElementById(id).text);
                    gl.compileShader(s);
                    gl.attachShader(p, s);
                });
                gl.linkProgram(p); return p;
            };

            const progBasic = createP("vs-basic", "fs-basic");
            const progDebug = createP("vs-debug", "fs-debug");

            const setupVAO = (geo) => {
                const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
                const bP = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bP); gl.bufferData(gl.ARRAY_BUFFER, geo.p, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                const bN = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bN); gl.bufferData(gl.ARRAY_BUFFER, geo.n, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
                const bI = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bI); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geo.i, gl.STATIC_DRAW);
                return vao;
            };

            const vaoSphere = setupVAO(getSphere(25, 32));
            const vaoCube = setupVAO(getCube(40));
            const vaoQuad = gl.createVertexArray(); gl.bindVertexArray(vaoQuad);
            const bQ = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bQ); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            const uLoc = (pr, name) => gl.getUniformLocation(pr, name);

            function draw() {
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clearStencil(0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

                const proj = mat4.perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1000);
                const view = mat4.lookAt([0, 60, 150], [0, 0, 0], [0, 1, 0]);

                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.STENCIL_TEST);
                gl.useProgram(progBasic);
                gl.uniformMatrix4fv(uLoc(progBasic, "u_proj"), false, proj);
                gl.uniformMatrix4fv(uLoc(progBasic, "u_view"), false, view);

                // --- ESFERA -> ESCRIBIR 1 EN STENCIL ---
                gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                gl.stencilMask(0xFF);
                gl.uniformMatrix4fv(uLoc(progBasic, "u_model"), false, mat4.translate(mat4.identity(), [-35, 0, 0]));
                gl.uniform3f(uLoc(progBasic, "u_color"), 0.7, 0.2, 0.2);
                gl.bindVertexArray(vaoSphere);
                gl.drawElements(gl.TRIANGLES, 32*32*6, gl.UNSIGNED_SHORT, 0);

                // --- CUBO -> ESCRIBIR 2 EN STENCIL ---
                gl.stencilFunc(gl.ALWAYS, 2, 0xFF); 
                // Nota: Si el cubo solapa a la esfera, el valor 2 sobreescribirá al 1 en el stencil
                gl.uniformMatrix4fv(uLoc(progBasic, "u_model"), false, mat4.translate(mat4.identity(), [35, 0, 0]));
                gl.uniform3f(uLoc(progBasic, "u_color"), 0.2, 0.2, 0.7);
                gl.bindVertexArray(vaoCube);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

                // --- PASE DE DEBUG MULTI-ID ---
                gl.disable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.useProgram(progDebug);
                gl.bindVertexArray(vaoQuad);
                gl.stencilMask(0x00); // Bloquear escritura para el debug

                // Visualizar ID 1 (Esfera) en Magenta
                gl.stencilFunc(gl.EQUAL, 1, 0xFF);
                gl.uniform4f(uLoc(progDebug, "u_debugColor"), 1.0, 0.0, 1.0, 0.5);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Visualizar ID 2 (Cubo) en Cyan
                gl.stencilFunc(gl.EQUAL, 2, 0xFF);
                gl.uniform4f(uLoc(progDebug, "u_debugColor"), 0.0, 1.0, 1.0, 0.5);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                gl.disable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                requestAnimationFrame(draw);
            }
            draw();
        }
        main();
    </script>
</body>
</html>